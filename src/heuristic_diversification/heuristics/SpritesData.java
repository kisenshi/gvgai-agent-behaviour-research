/**
 * Author: Cristina Guerrero
 * Date: 1st March 2021
 */

package heuristic_diversification.heuristics;

import java.util.ArrayList;
import java.util.HashMap;

import core.game.Event;
import core.game.Observation;
import core.game.StateObservation;
import heuristic_diversification.framework.MapDimensionsManager;
import heuristic_diversification.model.JSONManager;
import tools.Vector2d;

public class SpritesData {
    private MapDimensionsManager mapDimensions;
    private ArrayList<Integer> mGameSprites;   // sprites in the game discovered
    private ArrayList<Integer> mPlayerSprites; // sprites created from the player discoevered
    private HashMap<Integer, InteractionHistory> mStypesCollisions; // information related to the stypes of the sprites the player has collided with
    private HashMap<Integer, HashMap<Integer, InteractionHistory>> mStypesHits; // information related to the stypes of the sprites the player has hit with a sprite
    private int mLastNewSpriteDiscovered;
    private int mLastNewCollisionTick;
    private int mLastNewHitTick;
    private int mLastCuriosityTick; // curiosity is described as an interaction (collision or hit) in a new position of the map

    private class InteractionHistory {
        int nInteractions;
        ArrayList<Vector2d> interactionPositionsList;

        InteractionHistory() {
            nInteractions = 1;
            interactionPositionsList = new ArrayList<Vector2d>();
        }

        public void increaseInteractionCounter() {
            nInteractions++;
        }

        public boolean addInteractionAtPosition(Vector2d position) {
            if (!interactionPositionsList.contains(position)) {
                interactionPositionsList.add(position);
                return true;
            }
            return false;
        }
    }

    SpritesData(StateObservation stateObs) {
        this.mLastNewSpriteDiscovered = 0;
        this.mLastNewCollisionTick = 0;
        this.mLastNewHitTick = 0;
        this.mLastCuriosityTick = 0;
        
        this.mGameSprites = new ArrayList<Integer>();
        this.mPlayerSprites = new ArrayList<Integer>();
        this.mStypesCollisions = new HashMap<Integer, InteractionHistory>();
        this.mStypesHits = new HashMap<Integer, HashMap<Integer, InteractionHistory>>();
        
        this.mapDimensions = new MapDimensionsManager(stateObs);
    }

    /**
     * Update the list that contains the sprites generated by the avatar that have been
     * discovered by the agent.
     * Add the sprite type to mPlayerSprites if it is in the current observations and it
     * has not been seen before.
     * Maintain the last discovery game tick updated.
     * @param observations
     * @param gameTick
     */
    public void updatePlayerSprites(ArrayList<Observation>[] observations, int gameTick) {
        if (observations == null){
            return;
        }

        if (addNewSpritesToList(observations, mPlayerSprites)) {
            mLastNewSpriteDiscovered = gameTick;
        }
    }

    /**
     * Update the list that contains the sprites of the game that have been discovered by
     * the agent.
     * Add the sprite type to mGameSprites if it is in the current observations and it
     * has not been seen before.
     * Maintain the last discovery game tick updated.
     * @param observations
     * @param gameTick
     */
    public void updateGameSprites(ArrayList<Observation>[] observations, int gameTick) {
        if (observations == null){
            return;
        }

        if (addNewSpritesToList(observations, mGameSprites)) {
            mLastNewSpriteDiscovered = gameTick;
        }
    }

    /**
     * Record the collision event to the collision history. If a previous collision between
     * the avatar and the sprite has happened before, the counter is increased.
     * If the collision happened in a new position of the map, it is also recorded.
     * @param event collision event to record
     * @param gameTick the game tick when the collision happened
     */
    public void updateCollisionHistory(Event event, int gameTick) {
        int stypeCollidedWith = event.passiveTypeId;

        InteractionHistory spriteCollisionHistory;
        // Add sprite collided with to list
        if (!mStypesCollisions.containsKey(stypeCollidedWith)) {
            spriteCollisionHistory = new InteractionHistory();

            mStypesCollisions.put(stypeCollidedWith, spriteCollisionHistory);
            mLastNewCollisionTick = gameTick;
        } else {
            spriteCollisionHistory = mStypesCollisions.get(stypeCollidedWith);
            spriteCollisionHistory.increaseInteractionCounter();
        }

        // Record where the collision happened
        recordInteractionCoordinates(event, spriteCollisionHistory, gameTick);
    }

    /**
     * Record the hit event to the hit history. If a previous hit between
     * the sprites has happened before, the counter is increased. For this interaction, it is
     * possible that more than one sprite is generated from the avatar, so the one that hit will
     * be the one recorded.
     * If the hit happened in a new position of the map, it is also recorded.
     * @param event hit event to record
     * @param gameTick the game tick when the hit happened
     */
    public void updateHitHistory(Event event, int gameTick) {
        int stypeHit = event.passiveTypeId;
        int stypeUsed = event.activeTypeId;

        InteractionHistory spriteHitHistory;
        HashMap<Integer, InteractionHistory> mStypeHitsInformation;

        // Add sprite hit to list. As the avatar could create different sprites, we need to make a distinction between each of the possible sprites
        if (!mStypesHits.containsKey(stypeHit)) {
            spriteHitHistory = new InteractionHistory();
            mStypeHitsInformation = new HashMap<Integer, InteractionHistory>();
            mStypeHitsInformation.put(stypeUsed, spriteHitHistory);

            mStypesHits.put(stypeHit, mStypeHitsInformation);
            mLastNewHitTick = gameTick;
        } else {
            mStypeHitsInformation = mStypesHits.get(stypeHit);
            if (!mStypeHitsInformation.containsKey(stypeUsed)) {
                spriteHitHistory = new InteractionHistory();

                mStypeHitsInformation.put(stypeUsed, spriteHitHistory);
                mLastNewHitTick = gameTick;
            } else {
                spriteHitHistory = mStypeHitsInformation.get(stypeUsed);
                spriteHitHistory.increaseInteractionCounter();
            }
        }

        // Record where the hit happened
        recordInteractionCoordinates(event, spriteHitHistory, gameTick);
    }

    /**
     * Go through every observation to check if the sprite type has been discovered by
     * the agent and include it to the agent knowledge if not.
     * @param observations
     * @param spriteList list of sprite type ids to update
     * @return if a new sprite has been discovered
     */
    private boolean addNewSpritesToList(ArrayList<Observation>[] observations, ArrayList<Integer> spriteList) {
        int stype;
        boolean newSpriteDiscovered = false;

        for (int i=0; i < observations.length; i++){
            if (observations[i].size() > 0) {
                stype = observations[i].get(0).itype;
                if (!spriteList.contains(stype)) {
                    spriteList.add(stype);
                    newSpriteDiscovered = true;
                }
            }
        }

        return newSpriteDiscovered;
    }

    /**
     * Record the position where the interaction happened. If the interaction has not happened in that
     * position before, it is considered a new curiosity event. 
     * @param event interaction event to record
     * @param interactionHistory 
     * @param gameTick the game tick when the interaction happened
     */
    private void recordInteractionCoordinates(Event event, InteractionHistory interactionHistory, int gameTick) {
        Vector2d interactionPosition = event.position.copy();

        // The position of the interaction must be comverted to coordinates of a matrix
        int x = mapDimensions.getXFromVector(interactionPosition);
        int y = mapDimensions.getYFromVector(interactionPosition);
        Vector2d interactionCoordinates = new Vector2d(x, y);

        if (interactionHistory.addInteractionAtPosition(interactionCoordinates)) {
            mLastCuriosityTick = gameTick;
        }
    }

    /**
     * Debug method. Print spritesData info as JSON if it has been updated at the gametick provided.
     * @param gameTick
     */
    public void printUpdatedSpritesData(int gameTick) {
        if (hasBeenUpdated(gameTick)) {
            System.out.println("-- spritesData updated at "+ gameTick +"--");
            JSONManager.prinObjectAsJson(this, "spritesData_"+ gameTick);
        }
    }

    /**
     * Check if spritesData have been updated at the gametick provided.
     * @param gameTick
     * @return
     */
    private boolean hasBeenUpdated(int gameTick) {
        return ((gameTick == mLastNewSpriteDiscovered) 
             || (gameTick == mLastNewCollisionTick) 
             || (gameTick == mLastNewHitTick)
             || (gameTick == mLastCuriosityTick));
    }
}

/**
 * Author: Cristina Guerrero
 * Date: 1st March 2021
 */

package heuristic_diversification.heuristics;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map.Entry;

import core.game.Event;
import core.game.Observation;
import core.game.StateObservation;
import heuristic_diversification.framework.MapDimensionsManager;
import heuristic_diversification.model.JSONManager;
import tools.Vector2d;

public class SpritesData {
    private MapDimensionsManager mapDimensions;
    private ArrayList<Integer> mGameSprites;   // sprites in the game discovered
    private ArrayList<Integer> mPlayerSprites; // sprites created from the player discoevered
    private HashMap<Integer, InteractionHistory> mStypesCollisions; // information related to the stypes of the sprites the player has collided with
    private HashMap<Integer, HashMap<Integer, InteractionHistory>> mStypesHits; // information related to the stypes of the sprites the player has hit with a sprite
    private int mLastNewSpriteDiscovered;
    private int mLastNewCollisionTick;
    private int mLastNewHitTick;
    private int mLastCuriosityTick; // curiosity is described as an interaction (collision or hit) in a new position of the map

    private class InteractionHistory {
        private int nInteractions;
        private ArrayList<Vector2d> interactionPositionsList;

        InteractionHistory() {
            nInteractions = 1;
            interactionPositionsList = new ArrayList<Vector2d>();
        }

        public void increaseInteractionCounter() {
            nInteractions++;
        }

        public boolean addInteractionAtPosition(Vector2d position) {
            if (!interactionPositionsList.contains(position)) {
                interactionPositionsList.add(position);
                return true;
            }
            return false;
        }

        public int getNInteractions() {
            return nInteractions;
        }

        public int getNCuriosityInteractions() {
            return interactionPositionsList.size();
        } 

        public ArrayList<Vector2d> getCuriosityInteractions() {
            return interactionPositionsList;
        }

        public int nInteractionsNotFoundInReferenceList(ArrayList<Vector2d> positionListReference) {
            int newPosition = 0;
            for (Vector2d position : interactionPositionsList) {
                if (!positionListReference.contains(position)) {
                    newPosition++;
                }
            }
            return newPosition;
        }
    }

    SpritesData(StateObservation stateObs) {
        this.mLastNewSpriteDiscovered = 0;
        this.mLastNewCollisionTick = 0;
        this.mLastNewHitTick = 0;
        this.mLastCuriosityTick = 0;
        
        this.mGameSprites = new ArrayList<Integer>();
        this.mPlayerSprites = new ArrayList<Integer>();
        this.mStypesCollisions = new HashMap<Integer, InteractionHistory>();
        this.mStypesHits = new HashMap<Integer, HashMap<Integer, InteractionHistory>>();
        
        this.mapDimensions = new MapDimensionsManager(stateObs);
    }

    public final HashMap<Integer, InteractionHistory> getCollisionSpriteHistory() {
        return mStypesCollisions;
    }

    public final HashMap<Integer, HashMap<Integer, InteractionHistory>> getHitsSpriteHistory() {
        return mStypesHits;
    }

    public final HashMap<Integer, InteractionHistory> getHitSpriteHistory(int stype) {
        if (mStypesHits != null) {
            return mStypesHits.get(stype);
        }

        return null;
    }

    public final int getLastNewCollision() {
        return this.mLastNewCollisionTick;
    }

    public final int getLastNewHit() {
        return this.mLastNewHitTick;
    }

    public final int getLastCuriosity() {
        return this.mLastCuriosityTick;
    }

    /**
     * Update the list that contains the sprites generated by the avatar that have been
     * discovered by the agent.
     * Add the sprite type to mPlayerSprites if it is in the current observations and it
     * has not been seen before.
     * Maintain the last discovery game tick updated.
     * @param observations
     * @param gameTick
     */
    public void updatePlayerSprites(ArrayList<Observation>[] observations, int gameTick) {
        if (observations == null){
            return;
        }

        if (addNewSpritesToList(observations, mPlayerSprites)) {
            mLastNewSpriteDiscovered = gameTick;
        }
    }

    /**
     * Update the list that contains the sprites of the game that have been discovered by
     * the agent.
     * Add the sprite type to mGameSprites if it is in the current observations and it
     * has not been seen before.
     * Maintain the last discovery game tick updated.
     * @param observations
     * @param gameTick
     */
    public void updateGameSprites(ArrayList<Observation>[] observations, int gameTick) {
        if (observations == null){
            return;
        }

        if (addNewSpritesToList(observations, mGameSprites)) {
            mLastNewSpriteDiscovered = gameTick;
        }
    }

    /**
     * Record the collision event to the collision history. If a previous collision between
     * the avatar and the sprite has happened before, the counter is increased.
     * If the collision happened in a new position of the map, it is also recorded.
     * @param event collision event to record
     * @param gameTick the game tick when the collision happened
     */
    public void updateCollisionHistory(Event event, int gameTick) {
        int stypeCollidedWith = event.passiveTypeId;

        InteractionHistory spriteCollisionHistory;
        // Add sprite collided with to list
        if (!mStypesCollisions.containsKey(stypeCollidedWith)) {
            spriteCollisionHistory = new InteractionHistory();

            mStypesCollisions.put(stypeCollidedWith, spriteCollisionHistory);
            mLastNewCollisionTick = gameTick;
        } else {
            spriteCollisionHistory = mStypesCollisions.get(stypeCollidedWith);
            spriteCollisionHistory.increaseInteractionCounter();
        }

        // Record where the collision happened
        recordInteractionCoordinates(event, spriteCollisionHistory, gameTick);
    }

    /**
     * Record the hit event to the hit history. If a previous hit between
     * the sprites has happened before, the counter is increased. For this interaction, it is
     * possible that more than one sprite is generated from the avatar, so the one that hit will
     * be the one recorded.
     * If the hit happened in a new position of the map, it is also recorded.
     * @param event hit event to record
     * @param gameTick the game tick when the hit happened
     */
    public void updateHitHistory(Event event, int gameTick) {
        int stypeHit = event.passiveTypeId;
        int stypeUsed = event.activeTypeId;

        InteractionHistory spriteHitHistory;
        HashMap<Integer, InteractionHistory> mStypeHitsInformation;

        // Add sprite hit to list. As the avatar could create different sprites, we need to make a distinction between each of the possible sprites
        if (!mStypesHits.containsKey(stypeHit)) {
            spriteHitHistory = new InteractionHistory();
            mStypeHitsInformation = new HashMap<Integer, InteractionHistory>();
            mStypeHitsInformation.put(stypeUsed, spriteHitHistory);

            mStypesHits.put(stypeHit, mStypeHitsInformation);
            mLastNewHitTick = gameTick;
        } else {
            mStypeHitsInformation = mStypesHits.get(stypeHit);
            if (!mStypeHitsInformation.containsKey(stypeUsed)) {
                spriteHitHistory = new InteractionHistory();

                mStypeHitsInformation.put(stypeUsed, spriteHitHistory);
                mLastNewHitTick = gameTick;
            } else {
                spriteHitHistory = mStypeHitsInformation.get(stypeUsed);
                spriteHitHistory.increaseInteractionCounter();
            }
        }

        // Record where the hit happened
        recordInteractionCoordinates(event, spriteHitHistory, gameTick);
    }

    /**
     * Go through every observation to check if the sprite type has been discovered by
     * the agent and include it to the agent knowledge if not.
     * @param observations
     * @param spriteList list of sprite type ids to update
     * @return if a new sprite has been discovered
     */
    private boolean addNewSpritesToList(ArrayList<Observation>[] observations, ArrayList<Integer> spriteList) {
        int stype;
        boolean newSpriteDiscovered = false;

        for (int i=0; i < observations.length; i++){
            if (observations[i].size() > 0) {
                stype = observations[i].get(0).itype;
                if (!spriteList.contains(stype)) {
                    spriteList.add(stype);
                    newSpriteDiscovered = true;
                }
            }
        }

        return newSpriteDiscovered;
    }

    /**
     * Record the position where the interaction happened. If the interaction has not happened in that
     * position before, it is considered a new curiosity event. 
     * @param event interaction event to record
     * @param interactionHistory 
     * @param gameTick the game tick when the interaction happened
     */
    private void recordInteractionCoordinates(Event event, InteractionHistory interactionHistory, int gameTick) {
        Vector2d interactionPosition = event.position.copy();

        // The position of the interaction must be comverted to coordinates of a matrix
        int x = mapDimensions.getXFromVector(interactionPosition);
        int y = mapDimensions.getYFromVector(interactionPosition);
        Vector2d interactionCoordinates = new Vector2d(x, y);

        if (interactionHistory.addInteractionAtPosition(interactionCoordinates)) {
            mLastCuriosityTick = gameTick;
        }
    }

    /**
     * Number of sprites not present in the interaction history in the sprites data object provided 
     * as reference.
     * Interactions include both collisions and hits.
     * @param referenceSpritesData object taken as reference for comparison
     * @return number of new sprite interactions
     */
    public int nNewInteractions(final SpritesData referenceSpritesData) {
        return nNewCollisions(referenceSpritesData) + nNewHits(referenceSpritesData);
    }

    /**
     * Number of locations for each sprite (curiosity events) that are not present in the interaction history 
     * in the sprites data object provided as reference.
     * Interactions include both collisions and hits.
     * @param referenceSpritesData object taken as reference for comparison
     * @return number of new curiosity events
     */
    public int nNewCuriosityInteractions(final SpritesData referenceSpritesData) {
        return nNewCollisionCuriosityInteractions(referenceSpritesData) + nNewHitCuriosityInteractions(referenceSpritesData);
    }

    /**
     * Get number of total interactions with sprites in the data stored in SpritesData.
     * Interactions include both collisions and hits.
     * @return
     */
    public int nTotalInteractions() {
        return nCollisions() + nHits();
    }

    /**
     * Get the number of interactions of sprites in different positions (curiosity) in the data stored in SpritesData.
     * Interactions include both collisions and hits.
     * @return
     */
    public int nTotalCuriosityInteractions() {
        return nCollisionCuriosityInteractions() + nHitCuriosityInteractions();
    }

    /**
     * Returns the number of collisions with sprites in SpritesData that can't be found in the object taken as reference.
     * @param referenceSpritesData
     * @return
     */
    private int nNewCollisions(final SpritesData referenceSpritesData) {
        return nNewDistinctSprites(mStypesCollisions, referenceSpritesData.getCollisionSpriteHistory());
    }

    /**
     * Returns the number of hits of sprites in SpritesData that can't be found in the object taken as reference.
     * @param referenceSpritesData
     * @return
     */
    private int nNewHits(final SpritesData referenceSpritesData) {
        int nNewHits = 0;
        for (Entry<Integer, HashMap<Integer, InteractionHistory>> stypeHit : mStypesHits.entrySet()) {
            HashMap<Integer, InteractionHistory> referenceHitSpriteHistory = referenceSpritesData.getHitSpriteHistory(stypeHit.getKey());
            if (referenceHitSpriteHistory != null) {
                nNewHits += nNewDistinctSprites(stypeHit.getValue(), referenceHitSpriteHistory);
            } else {
                nNewHits += stypeHit.getValue().size();
            }
        }
        return nNewHits;
    }

    /**
     * Obtains the number of keys present in the first hashmap but not in the second.
     * To solve this, it is created a set containing the keys in both maps (union). When removing
     * the keys from the union that exist in the reference, those that are only in the first map
     * remain. We get the size of the final set.
     * @param spritesHistory
     * @param spritesHistoryReference
     * @return
     */
    private int nNewDistinctSprites(HashMap<Integer, InteractionHistory> spritesHistory, HashMap<Integer, InteractionHistory> spritesHistoryReference) {
        // Get the union of sprites of both history hashmap
        HashSet<Integer> spritesUnion = new HashSet<>(spritesHistory.keySet());
        spritesUnion.addAll(spritesHistoryReference.keySet());

        // Remove the reference sprites to obtain the unique ones (new ones) in spritesHistory
        spritesUnion.removeAll(spritesHistoryReference.keySet());

        return spritesUnion.size();
    }

    /**
     * Total of interactions of the collision type
     * @return
     */
    public int nCollisions() {
        return nInteractions(mStypesCollisions);
    }

    /**
     * Total of interactions of the hit type
     * @return
     */
    public int nHits() {
        int nHits = 0;
        for (HashMap<Integer, InteractionHistory> spritesHit : mStypesHits.values()) {
            nHits += nInteractions(spritesHit);
        }
        return nHits;
    }

    public int getNStypesInteractedWith() {
        int nStypesCollisions = mStypesCollisions.size();
        int nStypesHits = mStypesHits.size();

        return nStypesCollisions + nStypesHits;
    }

    /**
     * Sums the number of interactions for each sprite in the given spritesHistory to obtain the number of total of interactions.
     * @param spritesHistory Hashmap form by stype and the interaction history for each of them
     * @return total interactions
     */
    private int nInteractions(HashMap<Integer, InteractionHistory> spritesHistory) {
        int nInteractions = 0;
        for (InteractionHistory interactionHistory : spritesHistory.values()) {
            nInteractions += interactionHistory.getNInteractions();
        }
        return nInteractions;
    }

    /**
     * Gets the numner of new collision curiosities present in SpritesData taking as reference another object.
     * @param referenceSpritesData
     * @return
     */
    private int nNewCollisionCuriosityInteractions(final SpritesData referenceSpritesData) {
        return nNewDistinctCuriosityInteractions(mStypesCollisions, referenceSpritesData.getCollisionSpriteHistory());
    }

    /**
     * Gets the numner of new hit curiosities present in SpritesData taking as reference another object.
     * @param referenceSpritesData
     * @return
     */
    private int nNewHitCuriosityInteractions(final SpritesData referenceSpritesData) {
        int nNewHitCuriosityInteractions = 0;
        for (Entry<Integer, HashMap<Integer, InteractionHistory>> stypeHit : mStypesHits.entrySet()) {
            HashMap<Integer, InteractionHistory> referenceHitSpriteHistory = referenceSpritesData.getHitSpriteHistory(stypeHit.getKey());
            if (referenceHitSpriteHistory != null) {
                nNewHitCuriosityInteractions += nNewDistinctCuriosityInteractions(stypeHit.getValue(), referenceHitSpriteHistory);
            } else {
                nNewHitCuriosityInteractions += nCuriosityInteractions(stypeHit.getValue());
            }
        }
        return nNewHitCuriosityInteractions;
    }

    /**
     * Counts those curiosity interactions that are present in the first hashmap and not in the second one, 
     * which is taken as reference.
     * @param spritesHistory
     * @param spritesHistoryReference
     * @return
     */
    private int nNewDistinctCuriosityInteractions(HashMap<Integer, InteractionHistory> spritesHistory, HashMap<Integer, InteractionHistory> spritesHistoryReference) {
        int nNewCuriosityInteractions = 0;
        for (Entry<Integer, InteractionHistory> stypeHistory : spritesHistory.entrySet()) {
            int stype = stypeHistory.getKey();
            if (spritesHistoryReference.containsKey(stype)) {
                // We need to count only the different ones
                ArrayList<Vector2d> curiosityReferences = spritesHistoryReference.get(stype).getCuriosityInteractions();
                nNewCuriosityInteractions += stypeHistory.getValue().nInteractionsNotFoundInReferenceList(curiosityReferences);
            } else {
                // the sprite is not present in the reference, all curiosity is new
                nNewCuriosityInteractions += stypeHistory.getValue().getNCuriosityInteractions();
            }
        }
        return nNewCuriosityInteractions;
    }

    /**
     * Total of curiosities of the collision type
     * @return
     */
    private int nCollisionCuriosityInteractions() {
        return nCuriosityInteractions(mStypesCollisions);
    }

    /**
     * Total of curiosities of the hit type
     * @return
     */
    private int nHitCuriosityInteractions() {
        int nHitCuriosityInteractions = 0;
        for (HashMap<Integer, InteractionHistory> spritesHit : mStypesHits.values()) {
            nHitCuriosityInteractions += nCuriosityInteractions(spritesHit);
        }

        return nHitCuriosityInteractions;
    }

    /**
     * Sums the number of different locations where the interaction with each sprite has taken place (curiosity) to obtain the total 
     * for the given spritesHistory.
     * @param spritesHistory
     * @return
     */
    private int nCuriosityInteractions(HashMap<Integer, InteractionHistory> spritesHistory) {
        int nCuriosityInteractions = 0;
        for (InteractionHistory interactionHistory : spritesHistory.values()) {
            nCuriosityInteractions += interactionHistory.getNCuriosityInteractions();
        }
        return nCuriosityInteractions;
    }

    /**
     * Debug method. Print spritesData info as JSON if it has been updated at the gametick provided.
     * @param gameTick
     */
    public void printUpdatedSpritesData(int gameTick) {
        if (hasBeenUpdated(gameTick)) {
            System.out.println("-- spritesData updated at "+ gameTick +"--");
            printDebugSpritesData("spritesData_"+ gameTick);
        }
    }

    public void printDebugSpritesData(String fileName) {
        JSONManager.prinObjectAsJson(this, fileName);
    }

    /**
     * Debug method. Check if spritesData have been updated at the gametick provided.
     * @param gameTick
     * @return
     */
    private boolean hasBeenUpdated(int gameTick) {
        return ((gameTick == mLastNewSpriteDiscovered) 
             || (gameTick == mLastNewCollisionTick) 
             || (gameTick == mLastNewHitTick)
             || (gameTick == mLastCuriosityTick));
    }
}
